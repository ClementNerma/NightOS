# `sys::hw` service

The `sys::hw` service is in charge of hardware devices. It coordinates and manages communications with the hardware.

It is known as the [I/O manager](../../../technical/io-manager.md), or Ion.

- [Hardware detection](#hardware-detection)
- [Unique device identifier](#unique-device-identifier)
- [Device formats](#device-formats)
  - [Device type descriptor](#device-type-descriptor)
  - [Drivable device raw descriptor](#drivable-device-raw-descriptor)
  - [Driven device type](#driven-device-type)
- [Normalization](#normalization)
  - [Patterns](#patterns)
- [Drivers](#drivers)
  - [Driver selection](#driver-selection)
  - [A note on performances](#a-note-on-performances)
- [Latency reduction for storage devices](#latency-reduction-for-storage-devices)
  - [Direct driver access for `sys::fs`](#direct-driver-access-for-sysfs)
  - [Direct hardware access for `sys::fs`](#direct-hardware-access-for-sysfs)
- [Methods](#methods)
  - [`0x01` ENUM_DEVICES](#0x01-enum_devices)
  - [`0x02` SUBSCRIBE_DEVICES](#0x02-subscribe_devices)
  - [`0x10` REGISTER_DRIVER](#0x10-register_driver)
  - [`0x11` UNREGISTER_DRIVER](#0x11-unregister_driver)
  - [`0x20` NOTIFY_PROCESS](#0x20-notify_process)
  - [`0xA0` ASK_DRIVER](#0xa0-ask_driver)
- [Notifications](#notifications)
  - [0x02 `IDENTIFY_DEVICE`](#0x02-identify_device)
  - [0x03 `DEVICE_EVENT`](#0x03-device_event)
  - [0x10 `DEVICE_INTERRUPT`](#0x10-device_interrupt)
  - [0xA0 `DRIVER_METHOD_REQUEST`](#0xa0-driver_method_request)
  - [0xA1 `DEVICE_NORM_NOTIF`](#0xa1-device_norm_notif)

## Hardware detection

Hardware detection is handled by [the kernel itself](../../kernel/hardware.md#hardware-detection), which exposes a [_raw device descriptor_ (RDD)](../../kernel/hardware.md#raw-device-descriptor).

## Unique device identifier

Each device gets a _unique device identifier_ (UDI) encoded on 8 bytes, which identifies a unique hardware component. It is unique across components and consistent across reboots. Unlike the [KDI](../../kernel/hardware.md#kernel-device-identifier), the UDI is generated randomly to prevent from getting informations on the hardware just from the UDI.

The identification mechanism depends on the connection type and is yet to be specified.

## Device formats

This section describes the multiple formats used by this service to deal with devices.

### Device type descriptor

From the [RDD](../../kernel/hardware.md#raw-device-descriptor) is derived the _device type descriptor_ (DTD), which describes the device's type. Its composition and size depends on the connection type, but it varies from empty (0 byte) if the connection type guarantees no information, up to 256 bytes.

***The format remains to be determined but should be along the lines of a number-based equivalent of ModAlias, like :***

- PCI-Express:
  - Vendor (8 bytes)
  - Sub-vendor (8 bytes)
  - Type (8 bytes)
  - Sub-type (8 bytes)
  - ...
- ...

### Drivable device raw descriptor

A _drivable device raw descriptor_ (DDRD) is a 512-byte long data structure meant to be used by [drivers](#drivers). It uses the following format:

- [UDI](#unique-device-identifier) (8 bytes)
- [CII](../../kernel/hardware.md#connection-interface-identifier) (4 bytes)
- Size of the [DTD](#device-type-descriptor) (1 byte)
- [DTD](#device-type-descriptor) (256 bytes, unused weakest bytes filled with zeros)
- _Future-proof_

### Driven device type

A _driven device type_ (DDT), usually referred to as the _device type_, is generated by the [driver](#drivers) for each device it drives from the [DDRD](#drivable-device-raw-descriptor). This is a normalized value, used by the system to determine which actions can be performed through this device.

It's a 4-byte value, the strongest two bytes describing the _category_ and the weakest two the _sub-category_.

The following list contains all possible values for DDTs, but is **far from being complete yet**. It will also grow over time as new device types appear on the market.

- `0x0001`: Storage
  - `0x0001`: Hard drive
  - `0x0002`: SSD
  - `0x0003`: USB flash drive
  - `0x0004`: SD flash memory card
- ...

## Normalization

When a device is driven, other processes can ask this service to use _normalized methods_. These are methods that allow to perform a specific action or to receive [_normalized notifications_](#normalization) about specific events of a specific device.

Also, interrupts are normalized to ensure constancy across devices of the same type. They are sent to the driver processes using the [`DEVICE_EVENT`](#0x10-device_interrupt) notification.

The normalization of methods, notifications and interrupts is performed by the [driver](#drivers) in charge of the device.

There are several methods, depending on the [device's type (DDT)](#driven-device-type). Notifications differ as well.

You can find the **far from being complete** list in the relevant [specifications directory](../drivers/README.md). It will grow over time as new device types appear on the market and as existing devices evolve to provide new features.

### Patterns

Several methods of this service use _patterns_, which allow to match devices depending on several criterias.

A pattern is a data structure whose size varies from 5 to 277 bytes made of the following:

- Pattern (1 byte)
  - Bit 0: match all connection types
  - Bit 2: match all buses
  - Bit 3: match all ports
- Connection type (1 byte)
- Bus number (1 byte)
- Port number (1 byte)
- DTD length (1 byte) - `0` to omit DTD
- DTD pattern indicator (32 bytes, only if DTD) - indicates which bytes of the DTD must be used as patterns
- DTD (up to 256 bytes)

It's possible to match only devices that use a given connection type, and more specifically on a given bus and/or port.  

It's also possible to list only devices that match a specific DTD pattern. For that, the bit corresponding to the byte number in the DTD pattern indicator must be set.

For instance, providing the DTD `0x0100B2` with the DTD pattern indicator set to `0b01000000`, the second byte will match all devices.

## Drivers

From a higher level point of view, drivers are [services](../../services.md) that declare their parent applications as being able to handle certain type of devices through the [`REGISTER_DRIVER`](#0x10-register_driver) method, using [patterns](#patterns).

Registering as a driver for a pattern requires the application to expose the [driver service(s)](../../services.md#types-of-services) relevant to the [DDT](#driven-device-type) provided in the pattern.

When a device is connected, a driver is selected from the list of drivers able to handle this specific device. If the device is connected for the very first time, the selected driver process first receives an [`IDENTIFY_DEVICE`](#0x02-identify_device) notification to translate the [DDRD](#drivable-device-raw-descriptor) into a [DDT](#driven-device-type).

Then, the driver process receives a [`DEVICE_EVENT`](#0x03-device_event) notification, which will also be sent if the status of the device changes.

From this point, the driver can create an [AMS](../../kernel/memory.md#abstract-memory-segments) from the device's memory using the [`DEVICE_AMS`](../../kernel/syscalls.md#0x34-device_ams) syscall.

It can also get informed of interrupts the device raises through the [`DEVICE_INTERRUPT`](#0x10-device_interrupt) notification.

Other processes can then ask the driver to perform specific actions depending on the type of device, using [normalized methods](#normalization) which can be sent to the driver using the [`ASK_DRIVER`](#0xa0-ask_driver) method. The driver receives these informations through the [`DRIVER_METHOD_REQUEST`](#0xa0-driver_method_request) notification.

The driver is also in charge of translating the interrupts of a device as well as eventual events polled from its (mapped) memory to [normalized notifications](#normalization) which can then be sent to processes that subscribed to them using the related [normalized methods](#normalization).

You can see the complete list of methods and notifications for each type of driver services in the [related section of the documentation](../drivers/README.md).

### Driver selection

A driver is selected for a specific hardware component if it matches any of the following criterias, in decreasing importance order:

* The user selected this driver for this specific hardware component ;
* The user selected this driver for this specific type of hardware components ([pattern](#patterns)) ;
* This driver is the one with the most specific [pattern](#patterns) covering this hardware component ;
* This driver is the only one able to drive this specific hardware component ([DTD](#device-type-descriptor))

If no criteria is matched, the driver isn't selected to drive the given hardware component.

### A note on performances

Although hardware devices' interrupts are notified to the driver through [service socket notifications](../../kernel/ipc.md#methods-and-notifications), the latency is still minimal as soon as the driver listens to the [`RECV_SOCK_MSG`](../../kernel/signals.md#0x27-recv_sock_msg) signal, which like all signals uses interrupts and so guarantees a very low latency.

## Latency reduction for storage devices

### Direct driver access for [`sys::fs`](fs.md)

All operations related to storage devices are handled by the [`sys::fs`](fs.md) service. To avoid the cost of using `sys::hw` as a relay for hardware operations, the `sys::fs` service is allowed to directly communicate with all [storage driver services](../drivers/storage.md).

### Direct hardware access for [`sys::fs`](fs.md)

In case a specific storage device doesn't require a [dedicated driver](../drivers/storage.md), the `sys::fs` service can directly access the said hardware component.

## Methods

### `0x01` ENUM_DEVICES

Enumerate connected devices, reserved to [system services](../../services.md).

It's also possible to only count the number of devices matching the provided criterias by providing a start index and end index of `0`.

**Required permission:** `devices.enum`

**Arguments:**

- Start index (4 bytes)
- End index (4 bytes)
- [Pattern](#patterns) (277 bytes)

**Answer:**

- Number of found devices globally (4 bytes)
- Number of devices listed in this answer (4 bytes)
- [DDRD](#drivable-device-raw-descriptor) of each device (512 bytes * number of devices)
- `0x01` if some devices were masked due to insufficient permissions, `0x00` else (1 byte)

**Errors:**

- `0x10`: Start index is lower than the end index
- `0x11`: Invalid connection type
- `0x12`: Bus number was provided without a connection type
- `0x13`: Port number was provided without a connection type
- `0x14`: Both bus number and port number were provided
- `0x15`: Invalid DTD
- `0x20`: Client is not a [system service](README.md)
- `0x21`: Range is greater than the available answer size
- `0x22`: Provided bus was not found
- `0x23`: Provided port was not found

### `0x02` SUBSCRIBE_DEVICES

Subscribe to events related to devices matching a patterns, reserved to [system services](README.md).

All current and future devices matching this pattern will cause a [`DEVICE_EVENT`](#0x03-device_event) notification.

**Required permission:** `devices.subscribe`

**Arguments:**

- `0x00` to subscribe, any other value to unsubscribe
- [Pattern](#patterns) (277 bytes)

**Answer:**

_None_

**Errors:**

- `0x20`: Client is not a [system service](README.md)
- `0x21`: Asked to unsubscribe but no subscription is active for this pattern

### `0x10` REGISTER_DRIVER

Set up a service as a driver for all devices matching a pattern.  
If multiple drivers have colliding patterns, the final user will be prompted to choose a driver.  

When a new device is connected, the driver process will receive an [`IDENTIFY_DEVICE`](#0x02-identify_device) notification to translate the [DDRD](#drivable-device-raw-descriptor) into a [DDT](#driven-device-type).

The driver process will receive [`DEVICE_EVENT`](#0x03-device_event) notifications for drivable devices. This notification will only be sent for devices for which the system chose this driver as the main one.  
Notifications are also retroactive, which means they will be sent for already-connected devices.

The driver will also have the device registered in its [drivable devices attribute](../../kernel/processes.md#drivable-devices), allowing it to use the [`DEVICE_AMS`](../../kernel/syscalls.md#0x34-device_ams) syscall to map the device's memory in its own.

**Required permission:** `devices.register_driver`

**Arguments:**

- [Pattern](#patterns) of the devices to drive (up to 277 bytes)

**Answer:**

_None_

**Errors:**

- `0x20`: Current process is not a service
- `0x30`: Process' parent application does not expose the relevant [integration services](../../services.md#types-of-services)
- `0x31`: Current process is already registered as a driver for this pattern

### `0x11` UNREGISTER_DRIVER

Unregister a service [previously registered as a driver](#0x10-register_driver).

**Required permission:** _None_

**Arguments:**

- [Pattern](#patterns) to unsubscribe from (up to 277 bytes)

**Errors:**

- `0x30`: Current process is not registered as a driver for this pattern

### `0x20` NOTIFY_PROCESS

Send a notification to a process that registered itself for [normalized methods](#normalization) through a [normalized method](#normalization).

**Required permission:** _None_

**Arguments:**

- Notification ID (8 bytes)
- [_Normalized notification's content_](#normalization)

**Answer:**

_Expected answer by the notified process for this method if any_

**Errors:**

- `0x20`: Unknown notification ID

### `0xA0` ASK_DRIVER

Ask a [driver](#drivers) to use a [normalized method](#normalization) on a device it drives.

Reserved to [system services](README.md).

**Required permission:** `devices.ask_driver`

**Arguments:**

- Device's [UDI](#unique-device-identifier) (8 bytes)
- Method's code (4 bytes)
- Method's arguments (size depends on the method)

**Answer:**

_Expected answer format for this method_

**Errors:**

- `0x20`: Client is not a [system service](README.md)
- `0x21`: Unknown device UDI provided
- `0x22`: Provided method code is invalid for this device
- `0x23`: Invalid arguments provided for this method

## Notifications

### 0x02 `IDENTIFY_DEVICE`

Sent for a specific device the client that was [selected as its driver](#driver-selection).

**Datafield:**

- [DDRD](#drivable-device-raw-descriptor) (512 bytes)

**Expected answer:**

- [DTD](#drivable-device-raw-descriptor) (512 bytes)

**Errors:**

- `0x20`: The provided DTD is invalid
- `0x21`: The client does not expose the [driver service](../drivers/README.md) relevant to this type of device

### 0x03 `DEVICE_EVENT`

Sent for a specific device to clients that either:

- [Drives](#driver-selection) this specific device
- Subscribed to it using the [`SUBSCRIBE_DEVICES`](#0x02-subscribe_devices) method

**Datafield:**

- [DDT](#driven-device-type) (512 bytes)
- Event code (1 byte):
  - `0x10`: device was just connected
  - `0x11`: a driver was just selected for the device
  - `0x12`: the device is ready to use
  - `0x20`: device was disconnected (software)
  - `0x21`: the device is being disconnected by its driver
  - `0x22`: the device has been disconnected by the driver
  - `0x23`: the device was brutally disconnected (hardware)
  - `0x30`: device was just put to sleep
  - `0x31`: device was just awoken from sleep
- Indicator (1 byte):
  - Bit 0: set if this device is connected for the first time
  - Bit 1: set if this device was disconnected brutally (not by the system itself)
  - Bit 2: set if this device is connected for the first time on this specific port

### 0x10 `DEVICE_INTERRUPT`

Sent to a [driver](#drivers) after a device it's currently driving raised an interrupt.

**Datafield:**

- Device's [UDI](#unique-device-identifier) (8 bytes)
- [Normalized interrupt](#normalization)

### 0xA0 `DRIVER_METHOD_REQUEST`

Sent to a [driver](#drivers) after receiving a valid [normalized method request](#0xa0-ask_driver).

The driver is expected to answer using the relevant answer format for the provided [normalized method and arguments](#normalization).

The _notification ID_ is generated by this service to allow the driver to [send normalized notifications](#0x20-notify_process) to a process that registers for it through this method without showing the caller process' PID to the driver process.

**Datafield:**

- [DDT](#driven-device-type) (4 bytes)
- Notification ID (8 bytes)
- Method's code (4 bytes)
- Method's arguments (size depends on the method)

**Expected answer:**

_Expected answer format for this method if any_

### 0xA1 `DEVICE_NORM_NOTIF`

Sent to a process that subscribed to [normalized notifications](#normalization) of a device.  
This notification is transferred by the `sys::hw` service after the driver sent it its content through the [`NOTIFY_PROCESS`](#0x20-notify_process) method.

**Datafield:**

- Device's [UDI](#unique-device-identifier) (4 bytes)
- [_Normalized notification's content_](#normalization)

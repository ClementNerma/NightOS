# `sys::hw` service

The `sys::hw` service is in charge of hardware devices. It coordinates and manages communications with the hardware.

- [Hardware detection](#hardware-detection)
- [Device formats](#device-formats)
  - [Device type descriptor](#device-type-descriptor)
  - [Device identifier](#device-identifier)
  - [Driver device descriptor](#driver-device-descriptor)
  - [Driven device type](#driven-device-type)
- [Normalization](#normalization)
  - [Normalized methods](#normalized-methods)
  - [Normalized interrupts](#normalized-interrupts)
  - [Patterns](#patterns)
- [Drivers](#drivers)
- [Methods](#methods)
  - [`0x01` ENUM_DEVICES](#0x01-enum_devices)
  - [`0x02` SUBSCRIBE_DEVICES](#0x02-subscribe_devices)
  - [`0x10` REGISTER_DRIVER](#0x10-register_driver)
  - [`0x11` UNREGISTER_DRIVER](#0x11-unregister_driver)
  - [`0x12` DRIVE_DEVICE](#0x12-drive_device)
  - [`0x20` NOTIFY_PROCESS](#0x20-notify_process)
  - [`0xA0` ASK_DRIVER](#0xa0-ask_driver)
- [Notifications](#notifications)
  - [`DEVICE_EVENT`](#device_event)
  - [`DEVICE_INTERRUPT`](#device_interrupt)
  - [`DRIVER_METHOD_REQUEST`](#driver_method_request)

## Hardware detection

Hardware detection is handled by [the kernel itself](../kernel/hardware.md#hardware-detection), which then exposes a [_raw device descriptor_ (RDD)](../kernel/hardware.md#raw-device-descriptor) as well as a [_connection interface identifier_ (CII)](../kernel/hardware.md#connection-interface-identifier).

## Device formats

This section describes the multiple formats used by this service to deal with devices.

### Device type descriptor

From the RDD and CII is derived the _device type descriptor_ (DTD), which describes the device's type. Its composition and size depends on the connection type, but it varies from empty (0 byte) if the connection type guarantees no information, up to 256 bytes.

***The format remains to be determined but should be along the lines of a number-based equivalent of ModAlias, like :***

- PCI-Express:
  - Vendor (8 bytes)
  - Sub-vendor (8 bytes)
  - Type (8 bytes)
  - Sub-type (8 bytes)
  - ...
- ...

### Device identifier

It also derives a _unique device identifier_ (UDI) encoded on 265 bytes, which is made of:

- SDI (4 bytes)
- CII (4 bytes)
- Size of the DTD (1 byte)
- DTD (256 bytes, weakest bits filled with zeros)

### Driver device descriptor

A _driver device descriptor_ (DDD) is a data structure meant to be used by [drivers](#drivers). It uses the following format:

- Bytes 000-264: Device's UDI
- Bytes 265-272: Device's mappable length
- Bytes 273-512: _Future-proof_

### Driven device type

A _driven device type_ (DDT), usually referred to as the _device type_, is generated by the [driver](#drivers) for each device is drives. This is a normalized value, used by the system to determine which actions can be performed through this device.

It's a 4-byte value, the strongest two bytes describing the _category_ and the weakest two the _sub-category_.

The following list contains all possible values for DDTs, but is **far from being complete yet**. It will also grow over time as new device types appear on the market.

- `0x0001`: Storage
  - `0x0001`: Hard drive
  - `0x0002`: SSD
  - `0x0003`: USB flash drive
  - `0x0004`: SD flash memory card
- ...

## Normalization

### Normalized methods

When a device is driven, other processes can ask this service to use _normalized methods_. These are methods that allow to perform a specific action or to receive notifications about specific events of a specific device.

There are several methods, depending on the [device's type (DDT)](#driven-device-type). Notifications differ as well.

The following list contains all methods and related notifications for all DDTs, but is **far from being complete yet**. It will also grow over time as new device types appear on the market and as existing devices evolve to provide new features.

**TODO**

### Normalized interrupts

Some devices use interrupts to notify the system of a particular event. In such case, the interrupt is normalized to a format called the _normalized interrupt format_, which is then sent to the driver process using the [`DEVICE_EVENT`](#device_event) notification.

The normalized interrupt format depends on the [device's type (DDT)](#driven-device-type).

The following list contains all normalized interrupts for all DDTs, but is **far from being complete yet**. It will also grow over time as new device types appear on the market and as existing devices evolve to provide new features.

**TODO**

### Patterns

Several methods of this service use _patterns_, which allow to match devices depending on several criterias.

A pattern is a data structure whose size varies from 5 to 277 bytes made of the following:

- Pattern (1 byte)
  - Bit 0: match all connection types
  - Bit 2: match all buses
  - Bit 3: match all ports
- Connection type (1 byte)
- Bus number (1 byte)
- Port number (1 byte)
- DTD length (1 byte) - `0` to omit DTD
- DTD pattern indicator (16 bytes, only if DTD) - indicates which bytes of the DTD must be used as patterns
- DTD (up to 256 bytes)

It's possible to match only devices that use a given connection type, and more specifically on a given bus and/or port.  

It's also possible to list only devices that match a specific DTD pattern. For that, the bit corresponding to the byte number in the DTD pattern indicator must be set.

For instance, providing the DTD `0x0100B2` with the DTD pattern indicator set to `0b01000000`, the second byte will match all devices.

## Drivers

From a higher level point of view, drivers are [services](../services.md) that declare themselves as being able to handle certain type of devices through the [`REGISTER_DRIVER`](#0x10-register_driver) method, using [patterns](#patterns).

When a device is connected, using multiple criterias **which are yet to be determined**, a driver is selected from the list of drivers able to handle this specific device. This driver receives the [`DEVICE_EVENT`](#device_event) notification, which then allows it to drive the device using the [`DRIVE_DEVICE`](#0x12-drive_device) method.

## Methods

### `0x01` ENUM_DEVICES

Enumerate connected devices.

It's also possible to only count the number of devices matching the provided criterias by providing a start index and end index of `0`.

**Required permissions:**

- `devices.enum`

**Arguments:**

- Start index (4 bytes)
- End index (4 bytes)
- [Pattern](#patterns) (277 bytes)

**Answer:**

- Number of found devices globally (4 bytes)
- Number of devices listed in this answer (4 bytes)
- [DDD](#driver-device-descriptor) of each device (512 bytes * number of devices)

**Errors:**

- `0x10`: Start index is lower than the end index
- `0x11`: Invalid connection type
- `0x12`: Bus number was provided without a connection type
- `0x13`: Port number was provided without a connection type
- `0x14`: Both bus number and port number were provided
- `0x15`: Invalid DTD
- `0x20`: Range is greater than the available answer size
- `0x21`: Provided bus was not found
- `0x22`: Provided port was not found

### `0x02` SUBSCRIBE_DEVICES

Subscribe to events related to devices matching a patterns.  
All current and future devices matching this pattern will cause a [`DEVICE_EVENT`](#device_event) notification.

**Required permissions:**

- `devices.subscribe`

**Arguments:**

- `0x00` to subscribe, any other value to unsubscribe
- [Pattern](#patterns) (277 bytes)

**Answer:**

_None_

**Errors:**

- `0x20`: Asked to unsubscribe but no subscription is active for this pattern

### `0x10` REGISTER_DRIVER

Set up a service as a driver for all devices matching a pattern.  
If multiple drivers have colliding patterns, the final user will be prompted to choose a driver.  

The driver process will receive [`DEVICE_EVENT`](#device_event) notifications for drivable devices. This notification will only be sent for devices for which the system chose this driver as the main one.  
Notifications are also retroactive, which means they will be sent for already-connected devices.

**Required permissions:**

- `devices.register_driver`

**Arguments:**

- [Pattern](#patterns) of the devices to drive (277 bytes)

**Answer:**

_None_

**Errors:**

- `0x20`: Current process is not a service
- `0x30`: Current process is already registered as a driver for this pattern

### `0x11` UNREGISTER_DRIVER

Unregister a service [previously registered as a driver](#0x10-register_driver).

**Required permissions:**

- [Pattern](#patterns) to unsubscribe from (277 bytes)

**Arguments:**

_None_

**Errors:**

- `0x30`: Current process is not registered as a driver for this pattern

### `0x12` DRIVE_DEVICE

Drive a device this service is [registered as a driver](#0x10-register_driver) for.  
As the driver may not be chosen as the main driver for a device in case of patterns collision with another driver, this method should not be used before the driver process receives the related [notification](#device_event).

Before calling this method, it's recommanded to create a thread in the driver process to allow concurrent handling of the different devices, though this behaviour is not enforced.

Mapping can exceed the device's mappable size up to one page less one byte, which means if the size of a page is 4 KB and the device's mappable size is 15 KB, it's possible to map 4 pages, which the last bytes being unavailable (causing page faults if accessed).

**Required permissions:**

_None_

**Arguments:**

- Device's SDI (4 bytes)
- Relative device address to map (8 bytes)
- Number of memory pages to map from this device (8 bytes)
- Address in the driver process's memory space to map the driver at (8 bytes)

**Answer:**

_None_

**Errors:**

- `0x10`: Number of pages is zero
- `0x30`: Current process was not selected as the main driver for this pattern
- `0x31`: Cannot perform the mapping (device addresses out of range)
- `0x32`: Cannot perform the mapping (process addresses out of range)

### `0x20` NOTIFY_PROCESS

Send a notification to a process that registered itself for specific notifications through a [normalized method](#normalized-methods).

**Required permissions:**

_None_

**Arguments:**

- Notification ID (8 bytes)
- _Normalized notification for the provided method_

**Answer:**

_Expected answer by the notified process for this method if any_

**Errors:**

- `0x20`: Unknown notification ID

### `0xA0` ASK_DRIVER

Ask a [driver](#drivers) to use a [normalized method](#normalized-methods) on a device it drives.

**Required permissions:**

- `devices.perform_method`

**Arguments:**

- Device's SDI (4 bytes)
- Method's code (4 bytes)
- Method's arguments (size depends on the method)

**Answer:**

_Expected answer format for this method_

**Errors:**

- `0x20`: Unknown device SDI provided
- `0x21`: Provided method code is invalid for this device
- `0x22`: Invalid arguments provided for this method

## Notifications

### `DEVICE_EVENT`

Sent for a specific device to processes that either:

- [Drive](#drivers) this specific device
- Subscribed to it using the [`SUBSCRIBE_DEVICES`](#0x02-subscribe_devices) method

**Datafield:**

- [DDD](#driver-device-descriptor) (512 bytes)
- Event code (1 byte):
  - `0x10`: device was just connected
  - `0x11`: a driver was just selected for the device
  - `0x12`: the device is ready to use
  - `0x20`: device was disconnected (software)
  - `0x21`: the device is being disconnected by its driver
  - `0x22`: the device has been disconnected by the driver
  - `0x23`: the device was brutally disconnected (hardware)
  - `0x30`: device was just put to sleep
  - `0x31`: device was just awoken from sleep
- Indicator (1 byte):
  - Bit 0: set if this device is connected for the first time
  - Bit 1: set if this device was disconnected brutally (not by the system itself)
  - Bit 2: set if this device is connected for the first time on this specific port

### `DEVICE_INTERRUPT`

Sent to a [driver](#drivers) after a device it's currently driving raised an interrupt.

**Datafield:**

- Device's SDI (4 bytes)
- [Normalized interrupt](#normalized-interrupts)

### `DRIVER_METHOD_REQUEST`

Sent to a [driver](#drivers) after receiving a valid [normalized method request](#0xa0-ask_driver).

The driver is expected to answer using the relevant answer format for the provided [normalized method and arguments](#normalized-methods).

The _notification ID_ is generated by this service to allow the driver to [send normalized notifications](#0xa0-ask_driver) to a process that registers for it through this method without showing the caller process' PID to the driver process.

**Datafield:**

- [DDT](#driven-device-type) (4 bytes)
- Notification ID (8 bytes)
- Method's code (4 bytes)
- Method's arguments (size depends on the method)

**Expected answer:**

_Expected answer format for this method if any_

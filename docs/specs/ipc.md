# Inter-Process Communication

This document describes the way [Inter-Process Communication (IPC)](../technical/ipc.md) works.

## Pipes

_Inter-process Uni-directional Channels_ (IUC), also called _pipes_, allow two distinct processes to communicate.

Pipes are made of two uni-directional parts:

- A _sender channel_ (SC) which can only be written to (write-only)
- A _receiver channel_ (RC), which can only be read from (read-only)

The two processes sharing a pipes are:

- The _sender process_, which uses the SC to send data to the other process
- The _receiver process_, which uses the RC to retrieve data sent by the other process

The process that creates the pipe gets both the SC and the RC, and is expected to provide one of them to another process.

When a process is created, it gets several "forced" pipes:

| Pipe identifier | Standard pipe name | Format  | Description                                                                                                |
| --------------- | ------------------ | ------- | ---------------------------------------------------------------------------------------------------------- |
| STDIN           | Typed input        | _typed_ | Data coming either from a command pipe (`|`) or, if the input format is `buffer`, from an input pipe (`<`) |
| STDUSR          | Interactive input  | UTF-8   | Data coming from a terminal session (e.g. user inputs)                                                     |
| STDMSG          | Messages output    | UTF-8   | Messages to display in the console, which won't be redirected by default                                   |
| STDRAW          | Raw bytes          | Buffer  | Output data, which will be redirected if an output pipe (`>`) is used                                      |
| STDOUT          | Typed output       | _typed_ | Typed output data, which will be used by [shell scripts](shell-scripting.md))                              |

Each SC and RC has a unique identifier.

UTF-8 strings are sent as a couple of length + message, where the length is an unsigned integer on 32 bits.

### Opening pipes

A process can open a pipe with another process using the [`OPEN_WRITE_PIPE`](syscalls.md#0x40-open_write_pipe) (it send data) or the [`OPEN_READ_PIPE`](syscalls.md#0x41-open_read_pipe) (to receive data) syscall.

The other process will then respectively receive either the [`RECV_READ_PIPE`](signals.md#0x40-recv_read_pipe) or the [`RECV_WRITE_PIPE`](signals.md#0x41-recv_write_pipe) signal. If no handler is set when the signal is sent, the opening syscall fails.

### Pipes' pending data

When a pipe is written to, the data is written to a memory zone. This zone's content is called the _pending data_.  
When a pipe is read from, the pending data is progressively retrieved, erased as the read progresses.

There is a size limit to pending data though, of 64 KB, called the pipe's _capacity_.  
When it is reached, no data can be written to the pipe anymore, meaning the other process must read data from it in order to free space to write it.

### Closing pipes

Any of the two processes (be it the receiver or the sender) can close a pipe using the [`CLOSE_PIPE`](syscalls.md#0x46-close_pipe) syscall, providing its SC or RC identifier. The pipe is immediatly closed on both sides, and the other process receives the [`PIPE_CLOSED`](signals.md#0x42-pipe_closed) signal.

### Interactive usage

When an application process' [execution context](applications/context.md#execution-context) indicates this it was started from a command, the caller process will be able to:

- Send data to the callee's STDIN/STDUSR pipe ;
- Read data from the callee's STDMSG/STDRAW/STDOUT pipes

If the process is not started from a command, the STDIN and STDUSR pipes will never receive data and all data sent to the STDMSG, STDRAW and STDOUT pipes will be automatically ignored.

If the process terminates before the return value has been fully transmitted through STDOUT or if it closes the STDOUT pipe before fully transmitting the value, the process is considered as faulty and killed immediatly (if still alive). The calling script (if any) exits with an error message, unless the error is caught with `catch`, the error message being generated by the system.

Even if the process closes its STDMSG or STDRAW pipe properly (by calling the [`CLOSE_PIPE`](syscalls.md#0x46-close_pipe)), the command is not considered as finished until the process itself did not terminate.

Note that when a return value has been fully transmitted through STDOUT, all pipes are closed and the command is considered as finished.

## Shared Memory

**TODO**
